
//1966 : 프린터큐
//다시 풀어보기
//새로 알게된 것
//

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.Queue;
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //T 값 : 테스트 케이스 개수
        int T = Integer.parseInt(br.readLine());

        LinkedList<int[]> q = new LinkedList<>();

        //테스트케이스 T번 반복
        for(int i=0; i<T; i++){

            int max = 0; //가장 큰 중요도
            int cnt =1;  //몇 번째로 출력되었는지
            int pick_importance;

            StringTokenizer st = new StringTokenizer(br.readLine());
            int N = Integer.parseInt(st.nextToken());   //문서의 개수
            int M = Integer.parseInt(st.nextToken());   //몇 번째로 인쇄되었는지 궁금한 문서

            st = new StringTokenizer(br.readLine());

            //큐에다가 연결리스트 형식으로 문서의 순서 + 중요도 넣기
            for(int j=0; j<N; j++){
                q.offer(new int[] { j , Integer.parseInt(st.nextToken())});
                if(max < q.get(j)[1]){
                    max = q.get(j)[1];
                }
            }
            pick_importance = q.get(M)[1]; //픽한 문서의 중요도

//            System.out.println("max 중요도 : " + max);
//            System.out.println("몇 번째 픽 할꺼야? : " + M);
//            System.out.println("픽한 번째의 중요도: " + pick_importance);

            //while문 조건 : 픽한 문서 중요도가 가장 커야하며 현재 가장 앞에 있는 문서가 선택한 문서여야함
            while((pick_importance != max) || (q.peek()[0] != M)) {

                if (q.peek()[1] == max) { //만약 지금 문서가 가장 높은거면 없애버리고 cnt 증가
                    q.poll();
                    cnt++;
                    //System.out.println("max? : "+max);
                    //while문 안에서의 max값 다시 찾기
                    max = 0;
                    for (int j = 0; j < q.size(); j++) {

                        if (max < q.get(j)[1]) {
                            max = q.get(j)[1];
                        }
                    }
                }
                //지금 문서의 중요도가 max값과 같거나 작으면
                else if(q.peek()[1] <= max){
                    q.offer(q.poll());  //뒤로 보내기
                }
            }

            System.out.println(cnt);

            //큐에 남아있는 값 모두 제거하는 과정
            while(!q.isEmpty()) {
                q.poll();
            }
        }
    }
}
